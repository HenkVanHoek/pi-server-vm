# .github/workflows/build_release.yml

# A descriptive name for the workflow, which will be displayed on GitHub.
name: Create GitHub Release with Cross-Platform Executables

# This section defines the trigger for the workflow.
on:
  push:
    # It only runs when a new tag is pushed that matches the pattern 'v*.*.*'
    # For example: v1.4.1, v2.0.0, etc.
    tags:
      - "v*.*.*"

# This section defines the permissions the workflow's job will have.
# The 'contents: write' permission is required for the action that creates
# the GitHub Release and uploads assets to it.
permissions:
  contents: write

# This section defines the jobs that will run as part of the workflow.
jobs:
  # The 'build' job is responsible for creating the executables on different OSs.
  build:
    # The name of the job uses a variable from the 'matrix' to be descriptive.
    name: Build on ${{ matrix.os-name }}
    # The job will run on the virtual machine specified in the matrix.
    runs-on: ${{ matrix.os-vtu }}
    # The 'strategy' section defines a build matrix to run the job multiple times
    # with different configurations.
    strategy:
      matrix:
        include:
          - os-name: Linux
            os-vtu: ubuntu-latest
            asset-ext: tar.gz
          - os-name: macOS
            os-vtu: macos-latest
            asset-ext: tar.gz
          - os-name: Windows
            os-vtu: windows-latest
            asset-ext: zip

    steps:
      # Step 1: Check out the repository's code so the workflow can access it.
      - name: Check out the repository code
        uses: actions/checkout@v4

      # Step 2: Set up a specific version of Python.
      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      # Step 3: Install 'uv', the modern, fast Python package installer.
      # 'pipx' is used to install uv in an isolated environment, which is a best practice.
      - name: Install uv
        run: pipx install uv

      # Step 4: Install the project's dependencies using uv.
      # The --system flag tells uv to use the Python environment that was
      # already set up by the 'setup-python' action.
      - name: Install dependencies with uv
        run: uv pip install --system -e .[dev]

      # Step 5: Run our build script to create all the executables.
      - name: Build executables with PyInstaller
        run: python build.py

      # Step 6: Create a temporary directory to store the final archive.
      - name: Create package directory
        run: mkdir package

      # Step 7: Create a compressed archive of the 'dist' folder.
      # The archive type (.zip or .tar.gz) and name are dynamic based on the OS.
      - name: Create Archive
        uses: thedoctor0/zip-release@master
        with:
          type: '${{ matrix.asset-ext }}'
          directory: 'dist'
          filename: '../package/executables-${{ matrix.os-name }}.${{ matrix.asset-ext }}'

      # Step 8: Upload the created archive as a build artifact.
      # This allows the 'release' job to download and use it later.
      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: executables-${{ matrix.os-name }}
          path: ./package/*

  # The 'release' job is responsible for creating the official GitHub Release.
  release:
    name: Create GitHub Release
    # This job must wait for all the 'build' jobs to complete successfully.
    needs: build
    # It can run on a standard Ubuntu machine.
    runs-on: ubuntu-latest

    steps:
      # Step 1: Download all the build artifacts (the .zip and .tar.gz files)
      # that were uploaded by the different 'build' jobs.
      - name: Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      # Step 2: Create the GitHub Release and upload all the downloaded artifacts.
      - name: Create Release and Upload Assets
        uses: softprops/action-gh-release@v2
        with:
          # This fantastic feature automatically generates release notes
          # from the commits and pull requests since the last tag.
          generate_release_notes: true
          # This pattern finds all the files within the downloaded artifact
          # directories and uploads them as release assets.
          files: artifacts/**/*
